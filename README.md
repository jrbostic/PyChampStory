PyChampStory
============

DEPENDENCIES

Python 2

Tkinter gui toolbox



PROJECT OVERVIEW

At the time of this writing, PyChamp Story provides a starting script that gathers the user's name and prompts them to begin the game from a starting terminal.  The interface to provide loading saved games and accessing tutorial scripts from a particular folder is also stubbed out, although the functionality to actually save a game would require some additional integration and the actual tutorial scripts haven't been written.  This part of the application is meant to be a unique yet brief introduction to the larger body of the game, forcing the user to interact with “the computer” as if it is a person asking questions (and the player must answer to progress).  In future iterations this could be made more interesting but it is simply meant to give context to the rest of the gameplay.

Once the GUI portion of the game has been initiated by the user, the real bulk of application code comes into play.  On the front end, an auto-scaling 100-tile grid-based game board displays user's progress and location in the game world (drawn on a Tkinter Canvas).  As the player's character moves about the world, the contents of tiles become revealed and events are presented which require resolution.  Events appear in Tkinter Toplevel windows and are resolved based on user input or selection of appropriate options in what could be considered “challenges”.  These challenges are preliminary and limited to 3 particular formats at the moment--gift, option, and input events--but can be easily altered to incorporate new challenge paradigms.  Items are received by successfully completing challenges or by encountering special gift events where an item is offered without challenge.  Items in player's posession are displayed  in a small corner Tkinter Listbox as they are acquired.  A Tkinter Input widget has been modified to act as an input validation for players; the validator catches syntax errors in user input and ensures that only valid code can ever be executed.  The player is to valid Python code using available methods (for now).  Validity of input is conveyed to user by text color of program's validator, representing 3 states of the input: green is text that can be partially matched to a valid method, red indicates that user input does not match any known methods, and purple tells the user that they have successfully typed an executable statement.  When input is validated, and text turned to the color purple, then an adjacent “DO” button becomes clickable.  Above the validation box is a small console output, derived from a Tkinter Message widget, that records/displays text representations of player's most recent activities.  Above that is another Label widget that displays available player methods and parameter signatures.

On the back end, there is a board model that handles a tile data structure representing the board state.  The board model tracks things such as events, tile color, and whether tile has been visited.  Additionally, the tile data structure agenerates random events upon creation of each tile along with assigning randomized item rewards for completing challenges on that tile.  There is also a hero model that tracks state of the PyChamp character (i.e. items, statistics, current location) and contains the methods that are provided as available to player in the GUI.  When the player performs some hero activity that would alter the state of the board, the hero model queries a board method that updates state and optionally returns important values to the hero object.  

Communication between the model and view is generally done by a set of controller components, the most important of which is the Herometer.  The Herometer manages a number of important object references and provides some encapsulation functionality for communication between the different components.  Almost as important is a(n) job/event queue that exists to pass packages from the model to the view.  Packages passed through this event queue are then intermediately popped out of the queue by the main event loop and processed in sequence.  These are the fundamentals of what I did with PyChamp Story and generally how the application functions.  
	
	
	
PROJECT DYSFUNCTIONS AND FUTURE GOALS

So, what does the future of PyChamp Story hold?  I'm not sure.  Maybe further development or perhaps a complete redevelopment.  I don't think that the idea has been seen all the way through yet, so I hope that the current project can at least be viewed as a prototype of what might be done in the future.  The following are things that I would like to see implemented, expanded, or fixed in the future.

Event generation being a central part of the project's general goal of playability, it seems relatively important that the mechanism of delivery is designed in the most conducive way possible.  So, I would like to see the event window code moved to the view module and decoupled from the state information in the model's event generator.

Expansion of the regex data structure is a must.  Without increasing the size and flexibility of this structure, PyChamp Story would only ever be a shell of what it could.  Not only should the data structure support selective method testing (for circumstances where some actions are available while others are not), but it should also support variable numbers and types of parameters.  This might be one of the more exciting ideas for me, still it would probably have to be coupled with quite a bit more support code to make it easy to use.  It is particularly important that this happen though because input events are still being routed through the same validator as the original gameboard, thus have no missing or additional functionality (making it a little more boring than it should be).  This problem will also arise when adding leveling or skill upgrades of any kind; there has to be a smarter control structure for all of these options to be available simultaneously.

One idea that I liked pretty well was updating the toolbox.  Either recoding the frontend altogether or actually having phases of the game wherein the user transitions to progressively cleaner GUIs (perhaps somewhat by their own efforts).  This is a really nice idea but it definitely has the quality of being more conceptual than straightforward.  Nonetheless, I think it should stay on the table until it becomes entirely impractical.  It would be “cool”.

As far as some of the most very basic aspects are concerned, it would be important to actually write out some decent command-line tutorials (the interface for which is already established) as well as dealing with saving and loading game instances (presumably with Python's “pickling” system).  This is probably one of the easier things that I want to see happen, however it isn't terribly important while the player isn't able to make sufficiently unique progress.  Of course, this is a core must-have feature for any final version of a playable game.

And just to wrap it up and list a few more: better window-size/component scaling for different monitors, more images instead of solid background colors, images coupled to events or other objects in environment, more fleshed out items and skill progression, programmatic access to bag items and other environmental objects, an animated profile view of the hero that updates with hero state.  The list could go on, I'm sure.
